### 2주차: 프로세스 관리

**강의 목표:** 프로세스의 개념과 상태를 이해하고, 프로세스 제어 블록(PCB)의 역할을 학습합니다. 또한, C 언어를 사용하여 프로세스를 생성하고 관리하는 방법을 실습합니다.

**강의 내용:**

1. **프로세스 개념과 상태**
   - 프로세스란 무엇인가?
     - 실행 중인 프로그램의 인스턴스
     - 프로그램 코드(텍스트 섹션), 데이터 섹션, 힙, 스택으로 구성
   - 프로세스 상태
     - 생성(New): 프로세스가 생성 중인 상태
     - 준비(Ready): 실행될 준비가 된 상태
     - 실행(Running): CPU에서 실행 중인 상태
     - 대기(Waiting): I/O 등 이벤트를 기다리는 상태
     - 종료(Terminated): 실행이 완료된 상태
   - 상태 전이
     - 상태 간의 전이와 전이 이유

2. **프로세스 제어 블록 (PCB)**
   - PCB란 무엇인가?
     - 운영체제가 각 프로세스를 관리하기 위해 사용하는 데이터 구조
   - PCB의 주요 구성 요소
     - 프로세스 상태
     - 프로세스 번호(PID)
     - 프로그램 카운터
     - CPU 레지스터
     - 메모리 관리 정보
     - 회계 정보
     - 입출력 상태 정보

3. **프로세스 생성과 종료**
   - 프로세스 생성
     - `fork` 시스템 콜을 사용한 프로세스 생성
     - `fork`의 동작 방식 (부모와 자식 프로세스)
   - 프로세스 종료
     - `exit` 시스템 콜을 사용한 프로세스 종료
     - 부모 프로세스가 자식 프로세스의 종료를 기다리는 `wait` 시스템 콜

**실습:**

1. **`fork`와 `exec`를 이용한 프로세스 생성 및 관리**
   - 자식 프로세스를 생성하고, `exec`를 사용하여 다른 프로그램을 실행

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // 자식 프로세스
        printf("Child Process: PID = %d\n", getpid());
        execlp("/bin/ls", "ls", NULL);
    } else if (pid > 0) {
        // 부모 프로세스
        wait(NULL);  // 자식 프로세스가 종료될 때까지 대기
        printf("Child Complete\n");
    } else {
        // fork 실패
        printf("Fork failed\n");
    }
    
    return 0;
}
```

2. **프로세스 정보 출력**
   - 부모 프로세스와 자식 프로세스의 PID와 PPID 출력

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 자식 프로세스
        printf("Child Process: PID = %d, Parent PID = %d\n", getpid(), getppid());
    } else if (pid > 0) {
        // 부모 프로세스
        printf("Parent Process: PID = %d, Child PID = %d\n", getpid(), pid);
        wait(NULL);  // 자식 프로세스가 종료될 때까지 대기
    } else {
        // fork 실패
        printf("Fork failed\n");
    }

    return 0;
}
```

**과제:**

1. **여러 자식 프로세스 생성 및 관리**
   - 부모 프로세스가 여러 자식 프로세스를 생성하고 각 자식 프로세스에서 다른 프로그램을 실행하도록 합니다.
   - 자식 프로세스가 실행하는 프로그램을 다르게 설정하고, 부모 프로세스가 모든 자식 프로세스의 종료를 기다리도록 구현합니다.

2. **프로세스 트리 출력**
   - 부모 프로세스가 자식 프로세스를 생성하고, 자식 프로세스가 다시 자식 프로세스를 생성하여 트리 형태의 프로세스를 만듭니다.
   - 각 프로세스가 자신의 PID와 부모 PID를 출력하도록 구현합니다.

**퀴즈 및 해설:**

1. **프로세스의 주요 상태는 무엇인가요?**
   - 프로세스의 주요 상태는 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated)입니다.

2. **프로세스 제어 블록(PCB)의 역할은 무엇인가요?**
   - PCB는 운영체제가 각 프로세스를 관리하기 위해 사용하는 데이터 구조입니다. PCB에는 프로세스 상태, PID, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보, 입출력 상태 정보 등이 포함됩니다.

3. **`fork` 시스템 콜의 동작 방식은 무엇인가요?**
   - `fork` 시스템 콜은 새로운 프로세스를 생성합니다. `fork` 호출 후 부모 프로세스와 자식 프로세스가 생성되며, 자식 프로세스는 부모 프로세스의 복사본입니다. `fork`는 부모 프로세스에서는 자식 프로세스의 PID를 반환하고, 자식 프로세스에서는 0을 반환합니다.

**해설:**

1. **프로세스의 주요 상태**는 생성, 준비, 실행, 대기, 종료입니다. 각 상태는 프로세스의 실행 단계에 따라 전이됩니다. 예를 들어, 프로세스가 생성되면 준비 상태로 전이되고, CPU를 할당받으면 실행 상태로 전이됩니다. I/O 요청이 발생하면 대기 상태로 전이되며, 작업이 완료되면 종료 상태로 전이됩니다.

2. **프로세스 제어 블록(PCB)**는 운영체제가 프로세스를 관리하기 위해 사용하는 데이터 구조입니다. PCB에는 프로세스의 상태, 식별자, 메모리 정보, CPU 레지스터 상태 등 프로세스와 관련된 중요한 정보가 포함됩니다. PCB는 프로세스의 컨텍스트를 저장하고 복원하는 데 사용됩니다.

3. **`fork` 시스템 콜**은 새로운 프로세스를 생성합니다. 부모 프로세스가 `fork`를 호출하면 자식 프로세스가 생성되며, 자식 프로세스는 부모 프로세스의 복사본입니다. `fork` 호출 후, 부모 프로세스와 자식 프로세스는 동일한 프로그램 코드를 실행하지만, 서로 다른 메모리 공간을 사용합니다. `fork`는 부모 프로세스에서 자식 프로세스의 PID를 반환하고, 자식 프로세스에서는 0을 반환합니다.

이로써 2주차 강의를 마무리합니다. 다음 주차에는 스레드와 동기화에 대해 학습합니다. 추가 질문이 있거나 특정 주제에 대해 더 알고 싶다면 언제든지 문의해 주세요.